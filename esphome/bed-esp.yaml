esphome:
  name: bed-esp

esp32:
  board: esp32dev
  framework:
    type: arduino

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk_mode: GPIO0_IN
  phy_addr: 1
  power_pin: GPIO16
  manual_ip:
    static_ip: ${static_ip}
    gateway: !secret gateway
    subnet: !secret subnet
    dns1: !secret dns1

substitutions:
  static_ip: 192.168.1.146
  red: GPIO05
  green: GPIO33
  blue: GPIO32
  friendly_name: "Bed Lights"

logger:
api:
ota:

sensor:
  - platform: hx711
    gain: 128
#    name: "Bed Sensor"
    id: bed_weight
    dout_pin: GPIO14
    clk_pin: GPIO17
    filters:
      - delta: 3000
      # - calibrate_linear:
      #     - 314000 -> 0
      #     - 336000 -> 270
#      - sliding_window_moving_average:
#          window_size: 5
#          send_every: 3
      - lambda: |-
          if (x >= 0) return x;
          else return {};
#     - lambda: |-
#         if (x <= 500) return x;
#         else return {};
    # on_value:
    #   - if:
    #       condition:
    #         - lambda: |-
    #             static float last = 0.0;
    #             float diff = x - last;
    #             last = x;
    #             return x < 10.0 && diff < 1.0 && diff > - 1.0;
    #       then:
    #         - lambda: 'id(constant_weight) = x;'
    update_interval: 380ms
#    unit_of_measurement: lbs
    accuracy_decimals: 0
  - platform: homeassistant
    entity_id: sensor.colorloopstate
    id: hassstate

button:
  - platform: template
    name: Tare
    id: tare
    on_press:
      - lambda: |-
          id(zero) = id(bed_weight).state;
          
binary_sensor:
  - platform: template
    name: "Bed Occupancy"
    device_class: occupancy
    filters:
      delayed_off: 5s #avoid shifting being reported as clear
    lambda: |-
      if (id(bed_weight).state >= (id(zero) + 20000) ) {
        return true;
      } else {
        return false;
      }      

globals:
  - id: zero
    type: float
    restore_value: yes
    initial_value: '310000'
  # - id: constant_weight
  #   type: float
  # - id: auto_tare_enabled
  #   type: bool
  #   restore_value: yes
  #   initial_value: 'false'
  # - id: auto_tare_difference
  #   type: float
  #   restore_value: yes
  #   initial_value: '0'
  # - id: manual_tare_flag
  #   type: bool
  #   restore_value: no
  #   initial_value: 'false'

# binary_sensor:
#   - platform: template
#     name: "Bed Occupancy"
#     device_class: occupancy
#     lambda: |-
#       if (id(bed_weight).state > 150) {
#         return true;
#       } else {
#         return false;
#       }  

# switch:
#   ## Switch used to initiate a manual tare
#   - platform: template
#     id: bed_manual_tare_action_switch
#     name: "Bed Manual Tare Action"
#     lambda: |-
#       return id(manual_tare_flag);
#     turn_on_action:
#       - lambda: |-
#           id(zero) = id(bed_weight).state;
#       - switch.turn_off: bed_manual_tare_action_switch
#     turn_off_action:
#       - lambda: |-
#           id(manual_tare_flag) = false;
    
# # template sensors from global variables
# sensor:
#   - platform: template
#     id: bed_initial_zero
#     #name: "Bed Initial Zero"
#     lambda: |-
#       return id(initial_zero);
#     update_interval: 1s
    
#   - platform: template
#     id: bed_auto_tare_difference
#     #name: "Bed Auto Tare Difference"
#     lambda: |-
#       return id(auto_tare_difference);
#     update_interval: 1s
    
#   # sensors imported from home assistant
#   - platform: homeassistant
#     id: homeassistant_initial_zero
#     entity_id: input_number.bed_initial_zero
#     on_value:
#       then:
#         - lambda: |-
#             id(initial_zero) = x;
#   - platform: hx711
#     id: bed_hx711_value_raw
#     #name: "Bed Weight Value"
#     internal: True
#     dout_pin: GPIO14
#     clk_pin: GPIO17
#     update_interval: 1s
#     unit_of_measurement: kg
#     filters:
#       - sliding_window_moving_average:
#           window_size: 5
#           send_every: 1
#     on_value:
#       then:
#         - sensor.template.publish:
#             id: bed_hx711_value
#             state: !lambda 'return id(bed_hx711_value_raw).state;'
#         - if:
#             condition:
#               and:
#                 - lambda: 'return id(auto_tare_enabled);'
#                 # current bed value is below approx. 10KG (raw value -275743) aka nobody is standing on the scale
#                 - lambda: 'return id(bed_hx711_value).state < 10.0;'
#             then:
#               - if:
#                   condition:
#                     # current raw scale value is below expected zero value
#                     - lambda: 'return id(bed_hx711_value_raw).state < (id(initial_zero) - id(auto_tare_difference));'
#                   then:
#                     # INcrease Auto-Tare offset to slowly align real zero value with expected zero value
#                     - lambda: |-
#                         id(auto_tare_difference) += 10;
#                   else:
#                     # DEcrease Auto-Tare offset to slowly align real zero value with expected zero value
#                     - lambda: |-
#                         id(auto_tare_difference) -= 10;
#   # Mapped value to KG
#   - platform: template
#     id: bed_hx711_value
#     #name: "bed HX711 Value"
#     internal: False
#     filters:
#       # apply auto_tare difference
#       - lambda: 'return x + id(auto_tare_difference);'
#       # apply rough calibration
#       - calibrate_linear:
#           # retrieve these values by evaluating the raw values with loads of known mass.
#           # note that a bigger difference between measurements usually results in higher resolution,
#           # so measure 0 Kg and the highest known mass you have (like f.ex. your own weight, measured by a normal scale with good accuracy)
#           - 311000 -> 0
#           - 328355 -> 275
#       # map values below 0.1 to 0 (to decrease value changes due to random fluctuation)
#       - lambda: |-
#           if (x <= 0.1) {
#             return 0.0;
#           } else {
#             return x;
#           }
#     unit_of_measurement: lbs
#     accuracy_decimals: 0
#     update_interval: 380ms
  # - platform: homeassistant
  #   entity_id: sensor.colorloopstate
  #   id: hassstate

light:
  - platform: rgb
    id: leds
    name: "${friendly_name}"
    red: output_red
    green: output_green
    blue: output_blue
    restore_mode: RESTORE_DEFAULT_OFF
    effects:
      - random:
          name: Music
          transition_length: .1s
          update_interval: .2s
      - lambda:
          name: Color Loop
          lambda: |-
            static float state = 0;
            if (state != id(hassstate).state) {
              state = id(hassstate).state;
              auto call = id(leds).turn_on();
              call.set_transition_length(3000);
              if (state == 0) {
                call.set_rgb(0.45, 0.98, 0.39);
              } else if (state == 1) {
                call.set_rgb(0.45, 0.98, 0.93);
              } else if (state == 2) {
                call.set_rgb(0.38, 0.15, 0.96);
              } else if (state == 3) {
                call.set_rgb(0.5, 0.17, 0.96);
              } else {
                call.set_rgb(0.92, 0.2, 0.27);
              }
              call.perform();
            }

output:
  - platform: ledc
    id: output_red
    pin: ${red}
  - platform: ledc
    id: output_green
    pin: ${green}
  - platform: ledc
    id: output_blue
    pin: ${blue}